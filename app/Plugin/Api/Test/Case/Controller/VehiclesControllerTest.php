<?phpdefine('MIN_VAGA', 2);App::uses('ApiBaseControllerTestCase', 'Api.Lib');/** * Classe que efetua os testes da classe referente as ações dos Veículos */class VehiclesControllerTest extends ApiBaseControllerTestCase {	public $mockUser = false;	public $uses = array(		'Parking.Operador',		'Parking.Area',		'Parking.AreaPonto',		'Parking.Preco',		'Parking.ParkTarifa',		'Parking.Eticket',		'Parking.Cobranca',		'Parking.Historico',		'Parking.Ticket',		'Produto',		'Equipamento',		'Limite',		'Comunicacao',		'Historico'		);	// Variável que receberá todos os campos da classe (Default Fields And Command Fields)	private $data = NULL;	// Variável que receberá a URL para efetuar a requisição	private $URL = '/api/vehicles';	// Variável que receberá o formato dos dados da requisição	private $extension = '.json';	private $maxVaga = 20;	private $nVagas = 0;	/**	 * Método que é executado antes de cada teste	 */	public function setUp() {		parent::setUp();		$this->dataGenerator->savePreco();		$this->dataGenerator->saveProduto();		$this->dataGenerator->savePosto();		$this->dataGenerator->saveTarifa();		$this->dataGenerator->saveCobranca();		//cria uma área		$this->dataGenerator->saveArea(array('Area' => array('lista_fiscalizacao' => 'COM_IRREGULARIDADE_NAO_PAGA')));		$this->dataGenerator->saveSetor();		//cria vagas		$this->nVagas = rand(MIN_VAGA, $this->maxVaga);		for ($i = 1; $i <= $this->nVagas; $i++) {			$vaga = $this->dataGenerator->getAreaPonto();			$vaga['AreaPonto']['codigo'] = $i;			$this->dataGenerator->saveAreaPonto($vaga);		}		$this->dataGenerator->saveEquipamento(array('Equipamento' => array('tipo' => EQUIPAMENTO_TIPO_SMARTPHONE,'no_serie' => '1234567890','modelo' => 'ANDROID' ) ));		$this->dataGenerator->saveOperador(array('Operador' => array('usuario' => '1234567890','senha' => '1234567890')));				$this->dataGenerator->saveServico(array('Servico' => array('data_fechamento' => NULL)));		$this->parkTarifa = $this->dataGenerator->getParkTarifa();		$this->dataGenerator->saveParkTarifa($this->parkTarifa);		//cria historico		$nHistorico = MIN_VAGA * $this->nVagas;		for ($i = 0; $i < $nHistorico; $i++) {			$historico = $this->dataGenerator->getHistorico();			$vagaAtual = rand(1, $this->nVagas);			// $vagaAtual = $i + 1;			$historico['Historico']['vaga'] = $vagaAtual;			$historico['Historico']['pago_ate'] = NULL;			$historico['Historico']['removido_em'] = NULL;			$historico['Historico']['tolerancia_ate'] = date('Y-m-d H:i:s');			$historico['Historico']['irregularidades'] = 1;			$this->dataGenerator->saveHistorico($historico);		}		// Popula os campos default		$this->data = $this->getApiDefaultParams();		// Popula parâmetros do comando		$this->data['park_setor_id'] 		= $this->dataGenerator->setorId;		$this->data['placa']			 	= 'AND'. rand(1000,9999);		$this->data['vaga']			 		= rand(1, $this->nVagas);		$this->data['tipo_veiculo'] 		= 'CARRO';		$this->data['external_tolerance'] 	= NULL;		$this->data['external_code'] 		= NULL;		$this->data['area_id'] 				= $this->dataGenerator->areaId;	}	/**	 * Método para atualizar o tempo de remoção da área	 */	private function updateTempoRemocaoAutomatica($tempoRemocao){		$this->Area->id = $this->dataGenerator->areaId;		$this->Area->set('tmp_auto_remocao', $tempoRemocao);		$this->Area->save();	}// End Method 'updateTempoRemocaoAutomatica'	/**	 * Método que envia a requisição	 */	private function sendRequestData(){		$this->testAction($this->URL . $this->extension, array('method' => 'POST', 'data' => $this->data));	}// End Method 'sendRequest'	/**	* Método que efetua o teste esperando erro de Operação Inválida na action VIEW, pois na classe só deverá tratar a index	*/	public function testViewError() {		// Envia a requisição e valida a exceção recebida		$this->validateTestException(			$this->URL.'/1'.$this->extension,			'GET',			$this->data,			'NotImplementedException',			''		);	}// End method 'test_ViewError'	/**	* Método que efetua o teste esperando erro de Operação Inválida na action EDIT, pois na classe só deverá tratar a index	*/	public function testEditError() {		// Envia a requisição e valida a exceção recebida		$this->validateTestException(			$this->URL.'/1'.$this->extension,			'PUT',			$this->data,			'NotImplementedException',			''		);	}// End method 'test_EditError'	/**	 * Testa a requisição de listagem de veículos vencidos sem irregularidade	 */	public function testIndexVencidos() {		// Seta o parâmetro de vencidos		$this->data['list_mode'] = API_VEHICLE_LIST_MODE_OVERDUE;		// Apaga os históricos criados no setup		$this->Historico->deleteAll(array('Historico.id >= 1'));				// Cria novos históricos		$newHistoricos = rand(2,10);		for ($i = 0; $i < $newHistoricos; $i++) {			$historico = $this->dataGenerator->getHistorico();			$historico['Historico']['inserido_em'] = $this->dataGenerator->getDateTime('-1 hour');			$historico['Historico']['vaga'] = 1;			$historico['Historico']['pago_ate'] = $this->dataGenerator->getDateTime('-10 minutes');			$historico['Historico']['removido_em'] = NULL;			$historico['Historico']['tolerancia_ate'] = $this->dataGenerator->getDateTime('-30 minutes');			$this->dataGenerator->saveHistorico($historico);		}		// Acessa o link da API		$this->sendRequest($this->URL . $this->extension, 'GET', $this->data);		// Valida se houve retorno da classe testada		$this->assertNotNull($this->vars['data'], 'Nenhum dado foi retornado');		// Valida todos se todos os campos do retorno estão preenchidos		$this->assertNotEmpty($this->vars['data']['vehicles'], 'Historico');		// Confirma que o número de registros retornado é o esperado		$this->assertEqual(count($this->vars['data']['vehicles']), $newHistoricos, 'Número incorreto de registros retornados. Info - Retornados: ' .count($this->vars['data']['vehicles'])." Novos: $newHistoricos");	}	/**	 * Testa se deixa um veiculo Incompatível	 */	public function testIndexIncompativel() {		$this->dataGenerator->saveComissao(array('Comissao' => array('posto_id' => NULL)));		// Passa para o list_mode a Lista Incompativel		$this->data['list_mode'] = API_VEHICLE_LIST_MODE_INCOMPATIBLE;		// Pega a Primeira vaga livre		$areaPonto = $this->AreaPonto->find('all');		// Vende um Ticket para uma moto em vaga de carro. 		$this->dataGenerator->venderTicketEstacionamentoDinheiroMoto('2.00', 'POI-9876',$areaPonto['0']['AreaPonto']['codigo']);		// Verifica a Moto na vaga		$this->dataGenerator->verificaMoto('POI-9876', $areaPonto['0']['AreaPonto']['codigo']);		// Verifica a Moto na vaga 2		$this->dataGenerator->verificaMoto('LKJ-9876', $areaPonto['1']['AreaPonto']['codigo']);		// Acessa o link da API		$this->sendRequest($this->URL . $this->extension, 'GET', $this->data);				// Valida se houve retorno da classe testada		$this->assertNotNull($this->vars['data'], 'Nenhum dado foi retornado');		// Valida se os campos do retorno estão preenchidos		$this->assertNotEmpty($this->vars['data']['vehicles']['0']['Historico']);	}	public function testindexIrregulares() {		// Seta o parâmetro de irregulares		$this->data['list_mode'] = API_VEHICLE_LIST_MODE_NOTIFIED;		// Cria número aleatório de tickets		$numTickets = rand(2,7);		for ($i = 0; $i < $numTickets; $i++) {			$this->dataGenerator->saveTicket(					array(						'Ticket' => array(								'placa' 					=> $this->data['placa'],								'situacao' 					=> 'AGUARDANDO',								'pago_em'  					=> NULL,								'tipo'     					=> 'IRREGULARIDADE',								'equipamento_id_pagamento' 	=> NULL,								'nsu_pagamento' 			=> 0,								'data_fim'					=> $this->dataGenerator->getDateTime('+10 minutes'),								'entidade_id_pagamento' 	=> NULL, 								'servico_id_pagamento'		=> NULL,								'operador_id_pagamento' 	=> NULL, 								'motivo_irregularidade' 	=> 'FORA_DA_VAGA',								'numero_autuacao'			=> 0,								'historico_id'			 	=> $this->dataGenerator->historicoId						)					)			);		}		// Acessa o link da API		$this->sendRequest($this->URL . $this->extension, 'GET', $this->data);		// Valida se houve retorno da classe testada		$this->assertNotNull($this->vars['data'], 'Nenhum dado foi retornado');		// Confirma que o número de registros retornado é o esperado		$this->assertEqual(count($this->vars['data']['vehicles']), $numTickets, 'Número incorreto de registros retornados.');		// Valida todos se todos os campos do retorno estão preenchidos		for ($i = 0; $i < $numTickets; $i++) {			$this->assertNotEmpty($this->vars['data']['vehicles'][$i]['Historico'], 'Historico');			$this->assertNotEmpty($this->vars['data']['vehicles'][$i]['Ticket'], 'Ticket');		}	}	/**	 * Testa se a API irá retornar somente o aviso ativo	 */	public function testIndexIrregularesSomenteAvisosAtivos() {		// Seta o parâmetro de irregulares		$this->data['list_mode'] = API_VEHICLE_LIST_MODE_NOTIFIED;				// Cria dois avisos		for ($i = 0; $i < 2; $i++) {			$this->dataGenerator->saveTicket(array(				'Ticket' => array(					'placa' 					=> $this->data['placa'],					'situacao' 					=> 'AGUARDANDO',					'pago_em'  					=> NULL,					'tipo'     					=> 'IRREGULARIDADE',					'equipamento_id_pagamento' 	=> NULL,					'data_fim'					=> $this->dataGenerator->getDateTime('5 minutes'),					'nsu_pagamento' 			=> 0,					'valor'						=> 0,					'entidade_id_pagamento' 	=> NULL, 					'servico_id_pagamento'		=> NULL,					'operador_id_pagamento' 	=> NULL, 					'motivo_irregularidade' 	=> 'VENCIDO',					'numero_autuacao'			=> 0,					'historico_id'			 	=> $this->dataGenerator->historicoId					)				)			);		}		// Busca os avisos 		$tickets = $this->Ticket->find('all');		// Recupera o primeiro aviso		$ticketInterrompido = $tickets[0];		// Simula um aviso interrompido com este primeiro ticket		$ticketInterrompido['Ticket']['data_inicio'] = $this->dataGenerator->getDateTime('-20 minutes');		$ticketInterrompido['Ticket']['data_fim'] = $this->dataGenerator->getDateTime('-10 minutes');		$ticketInterrompido['Ticket']['observacao'] = 'Aviso Interrompido';		$this->Ticket->save($ticketInterrompido);		// Acessa o link da API		$this->sendRequest($this->URL . $this->extension, 'GET', $this->data);		// Valida se houve retorno da classe testada		$this->assertNotNull($this->vars['data'], 'Nenhum dado foi retornado');		// Confirma que se somente o aviso ativo foi retornado		$this->assertEqual(count($this->vars['data']['vehicles']), 1, 'Número incorreto de registros retornados.');			}	public function testIndexIrregularesSomenteNotificacoesAtivas() {		// Seta o parâmetro de irregulares		$this->data['list_mode'] = API_VEHICLE_LIST_MODE_NOTIFIED;				// Cria três notificações		for ($i = 0; $i < 3; $i++) {			$this->dataGenerator->saveTicket(array(				'Ticket' => array(					'placa' 					=> $this->data['placa'],					'situacao' 					=> 'AGUARDANDO',					'pago_em'  					=> NULL,					'tipo'     					=> 'IRREGULARIDADE',					'equipamento_id_pagamento' 	=> NULL,					'data_fim'					=> $this->dataGenerator->getDateTime('5 minutes'),					'nsu_pagamento' 			=> 0,					'entidade_id_pagamento' 	=> NULL, 					'servico_id_pagamento'		=> NULL,					'operador_id_pagamento' 	=> NULL, 					'motivo_irregularidade' 	=> 'VENCIDO',					'numero_autuacao'			=> 0,					'historico_id'			 	=> $this->dataGenerator->historicoId					)				)			);		}		// Busca as notificações 		$tickets = $this->Ticket->find('all');		// Recupera a primeira notificação		$ticketVencido = $tickets[0];		// Simula um aviso interrompido com este primeiro ticket		$ticketVencido['Ticket']['data_inicio'] = $this->dataGenerator->getDateTime('-20 minutes');		$ticketVencido['Ticket']['data_fim'] = $this->dataGenerator->getDateTime('-10 minutes');		$ticketVencido['Ticket']['observacao'] = 'Aviso Interrompido';		$this->Ticket->save($ticketVencido);		//Recupera a segunda notificação		$ticketPago = $tickets[1];		$ticketPago['Ticket']['situacao'] = 'PAGO';		$this->Ticket->save($ticketPago);				// Acessa o link da API		$this->sendRequest($this->URL . $this->extension, 'GET', $this->data);		// Valida se houve retorno da classe testada		$this->assertNotNull($this->vars['data'], 'Nenhum dado foi retornado');		// Confirma que se somente o aviso ativo foi retornado		$this->assertEqual(count($this->vars['data']['vehicles']), 1, 'Número incorreto de registros retornados.');	}	public function testIndexExcedidos() {				$preco = $this->Preco->findById($this->dataGenerator->precoId);		$preco['Preco']['tempo_max_periodos'] = 20;		$preco['Preco']['ignorar_tempo_max_periodo_compra'] = 1;		$this->dataGenerator->savePreco($preco);		// Seta o parâmetro de vencidos		$this->data['list_mode'] = API_VEHICLE_LIST_MODE_EXCEEDED;		// Apaga os históricos criados no setup		$this->Historico->deleteAll(array('Historico.id > 0'));		// Cria novos históricos		$newHistoricos = rand(2,7);		for ($i = 0; $i < $newHistoricos; $i++) {			$historico = $this->dataGenerator->getHistorico();			$historico['Historico']['inserido_em'] = $this->dataGenerator->getDateTime('-3 hour');			$historico['Historico']['vaga'] = 1;			$historico['Historico']['autuado'] = 0;			$historico['Historico']['situacao'] = 'LANCADO';			$historico['Historico']['irregularidades_emitidas'] = 0;			$historico['Historico']['pago_ate'] = $this->dataGenerator->getDateTime('+1 hour');			$historico['Historico']['removido_em'] = NULL;			$historico['Historico']['tolerancia_ate'] = $this->dataGenerator->getDateTime('-50 minutes');			$this->dataGenerator->saveHistorico($historico);		}		// Simula a troca de vaga do último veículos excedidos		$this->Historico->id = $this->dataGenerator->historicoId;		$this->Historico->set('ultima_troca_em', $this->dataGenerator->getDateTime());		$this->Historico->save();		// Atualiza o número de históricos excedidos		$newHistoricos--;		// Acessa o link da API		$this->sendRequest($this->URL . $this->extension, 'GET', $this->data);		// Valida se houve retorno da classe testada		$this->assertNotNull($this->vars['data'], 'Nenhum dado foi retornado');		// Valida todos se todos os campos do retorno estão preenchidos		$this->assertNotNull($this->vars['data']['vehicles'], 'A lista de veículos retornou nulo');		// Confirma que o número de registros retornado é o esperado		$this->assertEqual(count($this->vars['data']['vehicles']), $newHistoricos, 'Número incorreto de registros retornados. Info - Retornados: ' .count($this->vars['data']['vehicles'])." Novos: $newHistoricos");	}	/**	 * Teste se ele fica como irregular depois 	 */	public function testExcedidoIrregular() {		// Placa utilizada nos testes		$placa = 'GOM-3535';		// Deleta todas as vagas 		$vaga = 1;		$this->AreaPonto->deleteAll(array('AreaPonto.id >= ' => $vaga), false);		// Deleta todos os park_historicos		$this->Historico->deleteAll(array('Historico.id >= ' => $vaga), false);		// Vaga a ser utilizado no teste		$this->dataGenerator->saveAreaPonto(array('AreaPonto' => array('codigo' => $vaga)));		// Salva dados		$preco = $this->dataGenerator->getPreco();		$preco['Preco']['tempo_livre'] = 0;		$preco['Preco']['tempo_max_periodos'] = 1;		$preco['Preco']['ignorar_tempo_max_periodo_compra'] = 1;		$preco['Preco']['inserido_veiculo_excedido'] = 1;		$this->dataGenerator->savePreco($preco);		$precoId = $this->dataGenerator->precoId;		$this->Cobranca->updateAll(			array('Cobranca.preco_id_carro' => $precoId, 'Cobranca.preco_id_moto' => $precoId, 'preco_id_vaga_farmacia' => $precoId , 'preco_id_vaga_idoso' => $precoId, 'preco_id_irregularidade_vencido' => $precoId, 'preco_id_irregularidade_sem_ticket' => $precoId, 'preco_id_irregularidade_fora_vaga' => $precoId, 'preco_id_irregularidade_ticket_incompativel' => $precoId, 'preco_id_irregularidade_permanencia_excedida' => $precoId),			array('Cobranca.id >=' => 1)		);		$this->dataGenerator->saveComissao(array('Comissao' => array('posto_id' => null)));		$this->dataGenerator->saveTarifa();		$parkTarifa = $this->dataGenerator->getParkTarifa();		$parkTarifa['ParkTarifa']['valor'] = 2.00;		$parkTarifa['ParkTarifa']['minutos'] = 3;		$this->dataGenerator->saveParkTarifa($parkTarifa);		// Seta o parâmetro para excedidos		$this->data['list_mode'] = API_VEHICLE_LIST_MODE_NOTIFIED;		// Vende periodo Dinheiro		$this->dataGenerator->venderTicketEstacionamentoDinheiro('2.00', $placa);		// Lança uma irregularidade pro veiculo		$this->dataGenerator->emiteIrregularidade($placa, 1, 'PERMANENCIA_EXCEDIDA');		$historico = $this->Historico->findByPlaca($placa);		$historico['Historico']['inserido_em'] = $this->dataGenerator->getDateTime('-10 minutes');		$historico['Historico']['irregularidades'] = 1;		$this->dataGenerator->saveHistorico($historico);		//Faz o testAction		$this->sendRequest($this->URL . $this->extension, 'GET', $this->data);		$this->assertNotNull($this->vars['data']['vehicles'][0]['Historico']);		$this->assertNotNull($this->vars['data']['vehicles'][0]['Ticket']);		$this->assertNotNull($this->vars['data']['vehicles'][0]);		$this->assertNotNull($this->vars['data']['vehicles']);	}	/**	 * Testa requisição com modo de listagem inválido	 */	public function testInvalidListMode() {		$this->data['list_mode'] = 'INVALID';		$this->validateTestException(			$this->URL.$this->extension,			'GET',			$this->data,			'ApiException',			'Modo de lista de veículos inválido'		);	}	/**	* Testa acesso a API via POST, esperando exceção de "BadRequest" e a mensagem de parâmetro 'SetorId' está incorreto	*/	public function testAddVehicle_SemSetorIdEAreaId() {		// Retira o campo de SetorId		unset($this->data['park_setor_id']);		unset($this->data['area_id']);		// Envia a requisição e valida a exceção recebida		$this->validateTestException(			$this->URL.$this->extension,			'POST',			$this->data,			'ApiException',			'Área inválida'		);	}// End method 'test_AddVehicle_SemSetorId'	/**	* Testa acesso a API via POST, esperando exceção de "BadRequest" e a mensagem de parâmetro 'Placa' está incorreto	*/	public function testAddVehicle_SemPlaca() {		// Retira o campo de placa		unset($this->data['placa']);		// Envia a requisição e valida a exceção recebida		$this->validateTestException(			$this->URL.$this->extension,			'POST',			$this->data,			'ApiException',			'Placa não recebida'		);	}// End method 'test_AddVehicle_SemPlaca'	/**	* Testa acesso a API via POST, esperando exceção de "ApiExcepion" e a mensagem de parâmetro 'Vaga' está incorreto	*/	public function testAddVehicle_SemVaga() {		// Retira o campo de vaga		unset($this->data['vaga']);		// Envia a requisição e valida a exceção recebida		$this->validateTestException(			$this->URL.$this->extension,			'POST',			$this->data,			'ApiException',			'Vaga inválida'		);	}// End method 'test_AddVehicle_SemVaga'	/**	* Testa acesso a API via POST, esperando exceção de "BadRequest" e a mensagem de parâmetro 'TipoVeiculo' está incorreto	*/	public function testAddVehicle_SemTipoVeiculo() {		// Retira o campo de CobrancaId		unset($this->data['tipo_veiculo']);		// Envia a requisição e valida a exceção recebida		$this->validateTestException(			$this->URL.$this->extension,			'POST',			$this->data,			'ApiException',			'Tipo de veículo não recebido'		);	}// End method 'test_AddVehicle_SemTipoVeiculo'	/**	* Testa acesso a API via POST, esperando exceção de "BadRequest" e a mensagem de parâmetro 'external_code' é inválido	*/	public function testAddVehicle_InvalidExternalCode(){		// Popula campo de tolerância externa para poder validar o código externo		$this->data['external_tolerance'] = '00:00';		// Adiciona uma String no campo que deveria aceitar apenas números		$this->data['external_code'] = 'ANDROID';		// Envia a requisição e valida a exceção recebida		$this->validateTestException(			$this->URL.$this->extension,			'POST',			$this->data,			'ApiException',			'Código externo inválido'		);	}// End method 'test_AddVehicle_SemTipoVeiculo'	/**	* Testa acesso a API via POST, adicionando um veículo	*/	public function testAddVehicle() {		 // Variável que verificará se ocorreu ou não a exceção esperada    	$finalTester = false;    	// Variável que recebe a mensagem da exceção, caso ocorra    	$errorMessage = NULL;    	    	try {    		// Acessa o link da API			$this->sendRequest($this->URL . $this->extension, 'POST', $this->data);    	} catch(Exception $e) {    		// Seta variável de verificação para verdadeiro    		$finalTester = true;    		// Guarda a mensagem da exceção    		$errorMessage = $e->getMessage();    	}        // Valida variável de exceção indicando se ocorreu exceção.    	$this->assertFalse($finalTester, 'Ocorreu exceção inesperada: ' . $errorMessage);    	// Valida se houve retorno da classe testada		$this->assertNotNull($this->vars['data'], 'Nenhum dado foi retornado');		// Valida todos se todos os campos do retorno estão preenchidos		$this->assertNotNull($this->vars['data']['park_historico'], 'Campo park_historico está vazio');		// Valida se houve débito automático indevido		$this->assertTrue(empty($this->vars['data']['park_ticket']), 'Um débito automático indevido ocorreu');	}// End method 'test_AddVehicle'	/**	 * Testa o retorno de um e-ticket após a execução de um débito automático	 */	public function testVerifyVehicleWithETicket() {		// Atualiza a área para que consuma etickets		$this->Area->id = $this->dataGenerator->areaId;		$this->Area->saveField('consumir_eticket', 1);		// Gera etickets para o teste		$this->dataGenerator->geraEtickets(10, true);		// Cria tarifa e comissão genéricas		$this->dataGenerator->saveTarifa(array('Tarifa' => array('entidade_id' => null, 'posto_id' => null)));		$this->dataGenerator->saveComissao(array('Comissao' => array('entidade_id' => null, 'posto_id' => null)));		// Altera a configuração da área para ignorar a tolerância no débito automático		$this->Area->id = $this->dataGenerator->areaId;		$this->Area->saveField('debito_automatico_apos_tolerancia', 0);		// Cria um cliente com débito automático		$this->dataGenerator->saveCliente(array('Cliente' => array('autorizar_debito' => 1)));		// Concede limite para o cliente		$this->Limite->id = $this->Limite->field('id', array('entidade_id' => $this->dataGenerator->clienteId));		$this->Limite->saveField('pre_creditado', 1000);		// Salva uma placa associada a este cliente		$placa = $this->dataGenerator->getPlaca();		$this->dataGenerator->savePlaca($placa);		// Altera o pacote de dados enviado ao servidor para considerar esta placa		$this->data['placa'] = $placa['Placa']['placa'];   		// Acessa o link da API		$this->sendRequest($this->URL . $this->extension, 'POST', $this->data);		// Valida se houve retorno da classe testada		$this->assertNotNull($this->vars['data'], 'Nenhum dado foi retornado');		// Recupera o código do e-ticket		$eTicketToken = $this->vars['data']['compra_periodos']['e_ticket'];		// Testa se o e-ticket foi retornado		$this->assertNotNull($eTicketToken, 'E-ticket não foi retornado.');		// Por padrão, o lote é gerado para ser utilizado o hash como código do e-ticket		// Busca um e-ticket com o token igual ao código retornado pelo WS		$eTicket = $this->Eticket->findByToken($eTicketToken);		// Testa se o código é realmente o token		$this->assertTrue(!empty($eTicket), 'Valor retornado não é o token do e-ticket.');		// Altera a configuração do lote para usar o número sequencial em lugar do hash		$this->Eticket->Lote->id = $this->dataGenerator->loteId;		$this->Eticket->Lote->saveField('usar_numeracao', 1);		// Incrementa o NSU		$this->data['nsu']++;		// Cria uma nova placa		$placa = $this->dataGenerator->getPlaca();		$this->dataGenerator->savePlaca($placa);		// Altera o pacote de dados enviado ao servidor para considerar esta placa		$this->data['placa'] = $placa['Placa']['placa'];		// Acessa o link da API		$this->sendRequest($this->URL . $this->extension, 'POST', $this->data);		// Valida se houve retorno da classe testada		$this->assertNotNull($this->vars['data'], 'Nenhum dado foi retornado');		// Recupera o código do e-ticket		$eTicketSequencia = $this->vars['data']['compra_periodos']['e_ticket'];		// Testa se o e-ticket foi retornado		$this->assertNotNull($eTicketSequencia, 'E-ticket não foi retornado.');		// Busca um e-ticket com o token igual ao código retornado pelo WS		$eTicket = $this->Eticket->findBySequencia($eTicketSequencia);		// Testa se o código é realmente o token		$this->assertTrue(!empty($eTicket), 'Valor retornado não é o token do e-ticket.');	}	/**	* Testa a inserção de um veículo em uma vaga e a posterior	* adição do mesmo veículo em uma segunda vaga	*/	public function testAddVehicleToAnotherSpot() {		// Insere um carro na park histórico estacionado há 10 minutos		$oldSpot = $this->data['vaga'];		$vehicle = 'AFM-9999';		$pagoAte = $this->dataGenerator->getDateTime('+50 minutes');		$inseridoEm = $this->dataGenerator->getDateTime('-10 minutes');		$this->dataGenerator->saveHistorico(array('Historico' => array('vaga' => $oldSpot, 'removido_em' => null, 'inserido_em' => $inseridoEm, 'pago_ate' => $pagoAte, 'placa' => $vehicle)));		// Verifica se o carro foi corretamente estacionado		$parkedVehicle = $this->Historico->find('first', array('conditions' => array('vaga' => $oldSpot, 'placa' => $vehicle, 'situacao' => 'LANCADO')));		$this->assertTrue(!empty($parkedVehicle), 'Veículo não foi lançado na park_historico.');		$this->assertEmpty($parkedVehicle['Historico']['ultima_troca_em'], 'Campo ultima_troca_em foi indevidamente preenchido.');		// Cria uma nova vaga		$newSpot = $this->dataGenerator->getAreaPonto();		$this->dataGenerator->saveAreaPonto($newSpot);		// Altera os dados do request para considerar o veículo na nova vaga		$this->data['vaga'] = $newSpot['AreaPonto']['codigo'];		$this->data['placa'] = $vehicle;		$this->sendRequest($this->URL . $this->extension, 'POST', $this->data);		// Busca o veículo estacionado		$parkedVehicle = $this->Historico->find('all', array('conditions' => array('placa' => $vehicle)));		// Testa se o registro da park_historico foi atualizado (em vez de criar um novo registro)		$this->assertTrue(count($parkedVehicle) == 1, 'O veículo está duplicado no sistema.');		// Testa se o veículo está na nova vaga		$this->assertEquals($parkedVehicle[0]['Historico']['vaga'], $newSpot['AreaPonto']['codigo'], 'Veículo não foi adicionado à nova vaga');		// Testa se o campo 'ultima_troca_em' foi preenchido		$this->assertNotEmpty($parkedVehicle[0]['Historico']['ultima_troca_em'], 'Campo ultima_troca_em não foi preenchido.');	}// End method 'test_AddVehicle'	/**	 * Testa a inclusão de um veículo com débito automático	 */	public function testAddVehicleWithAutomaticDebit() {		// Cria tarifa e comissão genéricas		$this->dataGenerator->saveTarifa(array('Tarifa' => array('entidade_id' => null, 'posto_id' => null)));		$this->dataGenerator->saveComissao(array('Comissao' => array('entidade_id' => null, 'posto_id' => null)));		// Altera a configuração da área para ignorar a tolerância no débito automático		$this->Area->id = $this->dataGenerator->areaId;		$this->Area->saveField('debito_automatico_apos_tolerancia', 0);		// Cria um cliente com débito automático		$this->dataGenerator->saveCliente(array('Cliente' => array('autorizar_debito' => 1)));		// Concede limite para o cliente		$this->Limite->id = $this->Limite->field('id', array('entidade_id' => $this->dataGenerator->clienteId));		$this->Limite->saveField('pre_creditado', 1000);		// Salva uma placa associada a este cliente		$placa = $this->dataGenerator->getPlaca();		$this->dataGenerator->savePlaca($placa);		// Altera o pacote de dados enviado ao servidor para considerar esta placa		$this->data['placa'] = $placa['Placa']['placa'];		// Variável que verificará se ocorreu ou não a exceção esperada    	$finalTester = false;    	// Variável que recebe a mensagem da exceção, caso ocorra    	$errorMessage = NULL;    	try {    		// Acessa o link da API			$this->sendRequest($this->URL . $this->extension, 'POST', $this->data);    	} catch(Exception $e) {    		// Seta variável de verificação para verdadeiro    		$finalTester = true;    		// Guarda a mensagem da exceção    		$errorMessage = $e->getMessage();    	}        // Valida variável de exceção indicando se ocorreu exceção.    	$this->assertFalse($finalTester, 'Ocorreu exceção inesperada: ' . $errorMessage);    	// Valida se houve retorno da classe testada		$this->assertNotNull($this->vars['data'], 'Nenhum dado foi retornado');		// Valida retorno do JSONObject 'park_historico'		$this->assertNotNull($this->vars['data']['park_historico'], 'Dados da park_historico não foram retornados');		$this->assertNotNull($this->vars['data']['park_historico']['id'], 				'park_historico_id não retornado');		$this->assertNotNull($this->vars['data']['park_historico']['placa'], 			'park_historico_placa não retornado');		$this->assertNotNull($this->vars['data']['park_historico']['vaga'], 				'park_historico_vaga não retornado');		$this->assertNotNull($this->vars['data']['park_historico']['inserido_em'], 		'park_historico_inserido_em não retornado');		$this->assertNotNull($this->vars['data']['park_historico']['pago_ate'], 			'park_historico_pago_ate não retornado');		$this->assertNotNull($this->vars['data']['park_historico']['tolerancia_ate'], 	'park_historico_tolerancia_ate não retornado');		$parkArea = $this->Area->find('first');		$this->assertNotEmpty($parkArea);		// Valida configuração da área para consumo de eticket		if($parkArea['Area']['consumir_eticket']){			$this->assertNotNull($this->vars['data']['compra_periodos']['e_ticket'], 	'compra_periodos_e_ticket não retornado');		}		$this->assertNotNull($this->vars['data']['compra_periodos']['park_ticket_id'], 	'compra_periodos_park_ticket_id não retornado');		$this->assertNotNull($this->vars['data']['compra_periodos']['data_inicio'], 		'compra_periodos_data_inicio não retornado');		$this->assertNotNull($this->vars['data']['compra_periodos']['data_fim'], 		'compra_periodos_data_fim não retornado');		$this->assertNotNull($this->vars['data']['compra_periodos']['park_cobranca_id'], 'compra_periodos_park_cobranca_id não retornado');		$this->assertNotNull($this->vars['data']['compra_periodos']['tipo_veiculo'], 	'compra_periodos_tipo_veiculo não retornado');		$this->assertNotNull($this->vars['data']['compra_periodos']['qtde_periodos'], 	'compra_periodos_qtde_periodos não retornado');		$this->assertNotNull($this->vars['data']['compra_periodos']['valor_centavos'], 'pagamento_valor_centavos não retornado');		$this->assertEquals($this->vars['data']['compra_periodos']['vaga'], $this->data['vaga'], 'Número da vaga incorreto!');		$this->assertNotNull($this->vars['data']['pagamento']['nsu'], 			'pagamento_nsu não retornado');		$this->assertNotNull($this->vars['data']['cliente']['saldo_atual'], 		'cliente_saldo_atual não retornado');		$this->assertNotNull($this->vars['data']['cliente']['saldo_anterior'], 	'cliente_saldo_anterior não retornado');		$this->assertNotNull($this->vars['data']['autorizacao']['criado_em'], 	'autorizacao_criado_em não retornado');	}	/**	 * Testa a troca de veículo da vaga. O veículo anteriormente estacionado	 * deve ser movido para a vaga 0, sem afetar o período comprado	 */	public function testMoveVehicleFromSpot() {		// Cria a vaga e adiciona um veículo a ela		$spot = 9999;		$this->dataGenerator->saveAreaPonto(array('AreaPonto' => array('codigo' => $spot)));		// Adiciona o primeiro veículo à vaga		$vehicle1 = 'CBA-1234';		$pagoAte = $this->dataGenerator->getDateTime('+1hour');		$historicoId1 = $this->dataGenerator->saveHistorico(array('Historico' => array('vaga' => $spot, 'removido_em' => null, 'pago_ate' => $pagoAte, 'placa' => $vehicle1)));		// Verifica se o carro foi corretamente estacionado		$parkedVehicle1 = $this->Historico->find('first', array('conditions' => array('vaga' => $spot, 'placa' => $vehicle1, 'situacao' => 'LANCADO')));		$this->assertTrue(!empty($parkedVehicle1), 'Primeiro veículo não foi lançado na park_historico.');		// Insere um novo carro na mesma vaga		$vehicle2 = 'XYZ-9999';		$this->data['placa'] = $vehicle2;		$this->data['vaga'] = $spot;		$this->testAction($this->URL . $this->extension, array('method' => 'post', 'data' => $this->data));		// Verifica se o novo carro foi corretamente estacionado		$parkedVehicle2 = $this->Historico->find('first', array('conditions' => array('vaga' => $spot, 'placa' => $vehicle2, 'situacao' => 'LANCADO')));		$this->assertTrue(!empty($parkedVehicle2), 'Segundo veículo não foi lançado na park_historico.');		// Testa se os veículos estacionados são diferentes		$this->assertNotEqual($parkedVehicle1, $parkedVehicle2, 'Erro ao trocar o veículo: veículos são iguais');		// Testa se o primeiro veículo foi corretamente removido para a vaga zero		$parkedVehicle1 = $this->Historico->findById($historicoId1);		// $this->assertTrue($parkedVehicle1['Historico']['vaga'] == 0, 'Primeiro veículo não foi movido para a vaga 0.');		// Testa se houve alguma alteração indevida o tempo do período		$this->assertEqual($parkedVehicle1['Historico']['pago_ate'], $pagoAte, 'O pago_ate do período foi alterado indevidamente!');	}// End method 'testChangeVehicleFromSpot'	/**	 * Testa mover um veículo irregular de área.	 */	public function testMoveIrregularVehicleFromArea() {		// Cria a vaga e adiciona um veículo a ela		$areaPonto = $this->dataGenerator->getAreaPonto();		$areaPonto['AreaPonto']['codigo'] = 9999;		$this->dataGenerator->saveAreaPonto(array('AreaPonto' => array('codigo' => $areaPonto['AreaPonto']['codigo'])));		// Adiciona o primeiro veículo à vaga		$placa = 'CBA-1234';		$pagoAte = $this->dataGenerator->getDateTime('+1hour');		$ticket = $this->dataGenerator->getTicket();		$ticket['Ticket']['vaga'] = $areaPonto['AreaPonto']['codigo'];		$ticket['Ticket']['pago_ate'] = $pagoAte;		$ticket['Ticket']['placa'] = $placa;		$ticket['Ticket']['tipo'] = 'IRREGULARIDADE';		$ticket['Ticket']['situacao'] = 'PAGO';		$ticket['Ticket']['area_id'] = $areaPonto['AreaPonto']['area_id'];		$this->dataGenerator->saveTicket($ticket);		// Salva na park_historico.		$historicoId1 = $this->dataGenerator->saveHistorico(array('Historico' => array('vaga' => $ticket['Ticket']['vaga'], 'removido_em' => null, 'pago_ate' => $ticket['Ticket']['pago_ate'], 'placa' => $ticket['Ticket']['placa'])));		// Verifica se o carro foi corretamente estacionado		$parkedVehicle1 = $this->Historico->find('first', array('conditions' => array('vaga' => $ticket['Ticket']['vaga'], 'placa' => $ticket['Ticket']['placa'], 'situacao' => 'LANCADO')));		$this->assertTrue(!empty($parkedVehicle1), 'Primeiro veículo não foi lançado na park_historico.');		//Tenta efetuar a transferência do veículo.		//Cria um novo equipamento		$this->Equipamento->create();		$this->dataGenerator->saveEquipamento();		$this->dataGenerator->saveArea();		// Cria a vaga e adiciona um veículo a ela		$this->dataGenerator->saveSetor();		$this->dataGenerator->saveAreaPonto(array('AreaPonto' => array('codigo' => 1)));		// Transfere o veículo de área		$this->data['placa'] = $placa;		$this->data['vaga'] = 1;		$this->data['park_setor_id'] = $this->dataGenerator->setorId;		$this->testAction($this->URL . $this->extension, array('method' => 'post', 'data' => $this->data));	}	/**	 * Testa se um veículo foi removido de sua vaga via api. Um veículo removido deve ir para a vaga zero	 */	public function testDeleteVehicle(){		//código da vaga		$codigoVaga = 999;		//cria uma vaga		$vaga = $this->dataGenerator->getAreaPonto();		$vaga['AreaPonto']['codigo'] = $codigoVaga;		$this->dataGenerator->saveAreaPonto($vaga);		//adiciona um veículo à vaga		$historico = $this->dataGenerator->getHistorico();		$historico['Historico']['vaga'] = $codigoVaga;		$historico['Historico']['pago_ate'] = NULL;		$historico['Historico']['removido_em'] = NULL;		$historico['Historico']['tolerancia_ate'] = $this->dataGenerator->getDateTime('+1hour');		$this->dataGenerator->saveHistorico($historico);		//acessa a api para remover o veículo		$url = $this->URL . '/' . $this->dataGenerator->historicoId . $this->extension;		$this->testAction($url, array('method' => 'DELETE', 'data' => $this->data));		//busca veículo do banco de dados		$this->Historico->id = $this->dataGenerator->historicoId;		$historico2 = $this->Historico->read();		//testa se o veículo foi para a vaga zero		$this->assertEqual($this->dataGenerator->historicoId, $historico2['Historico']['id']);		$this->assertEqual(0, $historico2['Historico']['vaga']);	}// End method 'test_DeleteVehicle'	/**	 * Testa se o NSU está sendo incrementado ao acessar a api	 */	public function testIncrementNSU() {		$serial = '890r234jfwe908';		$nsu = 1;		$tipo = EQUIPAMENTO_TIPO_SMARTPHONE;		$modelo = 'ANDROID';		//Verifica que não há nenhuma comunicação		$comm = $this->Comunicacao->find('all');		$this->assertEmpty($comm);		//cria uma área		$this->dataGenerator->saveArea();		//cria um setor		$this->dataGenerator->saveSetor();		//cria uma vaga		$this->dataGenerator->saveAreaPonto();		//cria equipamento		$equipamento = $this->dataGenerator->getEquipamento();		$equipamento['Equipamento']['tipo']     = $tipo;		$equipamento['Equipamento']['modelo']   = $modelo;		$equipamento['Equipamento']['nsu']      = $nsu;		$equipamento['Equipamento']['no_serie'] = $serial;		$this->dataGenerator->saveEquipamento($equipamento);		//dados para request		$this->data['serial'] = $serial;		$this->data['nsu'] = $nsu + 1;		$this->data['tipo'] = $tipo;		$this->data['model'] = $modelo;		$this->data['park_setor_id'] = $this->dataGenerator->setorId;		//código da vaga		$codigoVaga = 999;		//cria uma vaga		$vaga = $this->dataGenerator->getAreaPonto();		$vaga['AreaPonto']['codigo'] = $codigoVaga;		$this->dataGenerator->saveAreaPonto($vaga);		$this->data['vaga'] = $codigoVaga;		//cria um serviço		$this->dataGenerator->saveServico(array('Servico' => array('data_fechamento' => NULL)));		//acessa API		$this->sendRequest($this->URL.$this->extension, 'POST', $this->data);		/*		 * testa se o NSU foi incrementado na base		*/		$equipamento = $this->Equipamento->findById($this->dataGenerator->equipamentoId);		$this->assertEqual($this->data['nsu'], intval($equipamento['Equipamento']['nsu']));		//testa se a comunicação foi criada		$comm = $this->Comunicacao->find('all');		$this->assertNotEmpty($comm);	}	/**	 * Teste mensagem de erro no débito automatico quando o mesmo não possui saldo	 * @return	 */	public function testDebitoAutomaticoSaldoInsuficiente() {		// Cria tarifa e comissão genéricas		$this->dataGenerator->saveTarifa(array('Tarifa' => array('entidade_id' => null, 'posto_id' => null)));		$this->dataGenerator->saveComissao(array('Comissao' => array('entidade_id' => null, 'posto_id' => null)));		// Altera a configuração da área para ignorar a tolerância no débito automático		$this->Area->id = $this->dataGenerator->areaId;		$this->Area->saveField('debito_automatico_apos_tolerancia', 0);		// Cria um cliente com débito automático		$this->dataGenerator->saveCliente(array('Cliente' => array('autorizar_debito' => 1)));		// Salva uma placa associada a este cliente		$placa = $this->dataGenerator->getPlaca();		$this->dataGenerator->savePlaca($placa);		// Altera o pacote de dados enviado ao servidor para considerar esta placa		$this->data['placa'] = $placa['Placa']['placa'];				// Faz a verificação; não pode lançar exception 'Saldo pré insuficiente', pois esta mensagem foi tratada		$this->sendRequest($this->URL . $this->extension, 'POST', $this->data);	}// End Method 'testDebitoAutomaticoSaldoInsuficiente'	/**	 * Testa acesso a API via POST, adicionando um veículo a uma vaga incompatível	 */	public function testAddVehicleVagaIncompativel() {		//tipo do veículo diferente do tipo da vaga		$this->data['tipo_veiculo'] = 'MOTO';		// Acessa o link da API		$this->sendRequest($this->URL . $this->extension, 'POST', $this->data);		//Busca da base		$historico = $this->Historico->findByPlaca($this->data['placa']);		//Verifica se o veículo foi inserido com o tipo informado		$this->assertEqual($this->data['tipo_veiculo'], $historico['Historico']['veiculo'], 'Tipo diferente do informado');	}// End method 'test_AddVehicle'	/**	 * Testa se o veículo lançado em uma vaga de deficiente ganhará o tempo de remoção automático da área	 */	public function testLancaVeiculoVagaDeficiente(){		// Cria valores default para o teste		$placa = 'XXX-1234';		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Cria uma vaga de deficiente		$vagaDeficiente = $this->dataGenerator->createDeficientSpot();		// Cria uma vaga normal		$vagaNormal     = $this->dataGenerator->createNormalSpot();		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga(deficiente)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaDeficiente['AreaPonto']['codigo'];		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca o histórico da placa		$parkHistorico = $this->Historico->findByPlaca($placa);		// Valida se encontrou o histórico		$this->assertNotNull($parkHistorico);				// Valida se o campo 'pago_ate' está preenchido		$this->assertNotNull($parkHistorico['Historico']['pago_ate']);		// Cria objetos DateTime para efetuar a comparação e busca a diferença em minutos entre os campos		$inseridoEmDateTime = new DateTime($parkHistorico['Historico']['inserido_em']);		$pagoAteDateTime = new DateTime($parkHistorico['Historico']['pago_ate']);		// Cria objeto de diferenças entre as datas		$interval = $inseridoEmDateTime->diff($pagoAteDateTime);		// Valida se a diferença do tempo em minutos é igual ao tempo da remoção automática		$this->assertEquals($tempoRemocaoAutomatica, $interval->i);	} // End Method 'test_LancaVeiculoVagaDeficiente'	/**	 * Testa se o veículo lançado em uma vaga de deficiente e for para uma vaga normal, nascerá como vencido 	 * devido a o pago_ate ser atualizado para data atual e o tempo de tolerância NÃO FOR renovado pela configuração 	 * 'Renovar tolerância na troca da vaga'	 */	public function testLancaVeiculoDeficienteTrocaVagaNormalVencido(){		// Cria valores default para o teste		$placa = 'XXX-1234';		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Cria uma vaga de deficiente		$vagaDeficiente = $this->dataGenerator->createDeficientSpot();		// Cria uma vaga normal		$vagaNormal     = $this->dataGenerator->createNormalSpot();		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga(deficiente)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaDeficiente['AreaPonto']['codigo'];		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca o histórico da placa		$parkHistorico = $this->Historico->findByPlaca($placa);		// Valida se encontrou o histórico		$this->assertNotNull($parkHistorico);				// Valida se o campo 'pago_ate' está preenchido		$this->assertNotNull($parkHistorico['Historico']['pago_ate']);		// Cria objetos DateTime para efetuar a comparação e busca a diferença em minutos entre os campos		$inseridoEmDateTime = new DateTime($parkHistorico['Historico']['inserido_em']);		$pagoAteDateTime = new DateTime($parkHistorico['Historico']['pago_ate']);		// Cria objeto de diferenças entre as datas		$interval = $inseridoEmDateTime->diff($pagoAteDateTime);		// Valida se a diferença do tempo em minutos é igual ao tempo da remoção automática		$this->assertEquals($tempoRemocaoAutomatica, $interval->i);		// Verifica o veículo na vaga normal. OBS: é feito manualmente assim pois não é possível fazer dois request's		$this->dataGenerator->verificaVeiculo($placa, $vagaNormal['AreaPonto']['codigo']);		// Busca histórico após verificação na vaga normal		$newParkHistorico = $this->Historico->findByPlaca($placa);		// Busca horário do banco atual		$dateTimeNow = $this->dataGenerator->getDateTime();		// Compara a data atual com o horário do campo 'pago_ate', pois o mesmo deverá ser vencido		$this->assertEquals($dateTimeNow, $newParkHistorico['Historico']['pago_ate']);	} // End Method 'test_LancaVeiculoDeficienteTrocaVagaNormalVencido'	/**	 * Testa veículo lançado sem período em uma vaga normal e após lançado em uma vaga de deficiente. 	 * O veículo deverá atualizar o pago_ate com o tempo da remoção automática da área, e ter seu status como pago.	 */	public function testLancadoVagaNormalTrocaVagaDeficientePago(){		// Cria valores default para o teste		$placa = 'XXX-1234';		$tempoLivre = 5;		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Atualiza o campo 'tempo_livre' do preço		$this->Preco->id = $this->dataGenerator->precoId;		$this->Preco->set('tempo_livre', $tempoLivre);		$this->Preco->save();		// Cria uma vaga de deficiente		$vagaDeficiente = $this->dataGenerator->createDeficientSpot();		// Cria uma vaga normal		$vagaNormal     = $this->dataGenerator->createNormalSpot();		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga(deficiente)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaNormal['AreaPonto']['codigo'];		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca o histórico da placa		$parkHistorico = $this->Historico->findByPlaca($placa);		// Valida se encontrou o histórico		$this->assertNotNull($parkHistorico);		// Valida se o campo 'pago_ate' está preenchido		$this->assertNull($parkHistorico['Historico']['pago_ate']);		// Cria objetos DateTime para efetuar a comparação e busca a diferença em minutos entre os campos		$toleranciaAteDateTime = new DateTime($parkHistorico['Historico']['tolerancia_ate']);		$dateTimeNow = new DateTime($this->dataGenerator->getDateTime());		// Cria objeto de diferenças entre as datas		$interval = $toleranciaAteDateTime->diff($dateTimeNow);		// Valida se a diferença do tempo em minutos é igual ao tempo da remoção automática		$this->assertEquals($tempoLivre, $interval->i);		// Verifica o veículo na vaga deficiente. OBS: é feito manualmente assim pois não é possível fazer dois request's		$this->dataGenerator->verificaVeiculo($placa, $vagaDeficiente['AreaPonto']['codigo']);		// Busca histórico após verificação na vaga normal		$newParkHistorico = $this->Historico->findByPlaca($placa);		// Compara a data atual com o horário do campo 'pago_ate', pois o mesmo deverá ser pago		$this->assertEquals($this->dataGenerator->getDateTime('+' . $tempoRemocaoAutomatica . ' Minutes'), $newParkHistorico['Historico']['pago_ate']);	} // End Method 'test_LancadoVagaNormalTrocaVagaDeficientePago'	/**	* Testa se o veículo lançado em uma vaga normal COM períodos vigentes for para uma vaga de deficiente, o mesmo	* deverá manter o 'pago_ate' do ticket, mantendo a situação do veículo como PAGO	*/	public function testComPeriodoVagaNormalTrocaVagaDeficienteMesmoPagoAte(){		// Cria valores default para o teste		$placa = 'XXX-1234';		$tempoLivre = 5;		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Atualiza o campo 'tempo_livre' do preço		$this->Preco->id = $this->dataGenerator->precoId;		$this->Preco->set('tempo_livre', $tempoLivre);		$this->Preco->save();		// Cria uma vaga de deficiente		$vagaDeficiente = $this->dataGenerator->createDeficientSpot();		// Cria uma vaga normal		$vagaNormal     = $this->dataGenerator->createNormalSpot();		// Salva dados necessários para efetuar uma compra de período em dinheiro		$this->dataGenerator->saveComissao(array('Comissao' => array('posto_id' => NULL)));		$this->dataGenerator->saveTarifa();		$this->dataGenerator->venderTicketEstacionamentoDinheiro('2.00', $placa, $vagaNormal['AreaPonto']['codigo']);		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga(deficiente)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaDeficiente['AreaPonto']['codigo'];		// Busca dados do histórico antes de enviar a requisição		$oldParkHistorico = $this->Historico->findByPlaca($placa);		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca dados do histórico depois do request		$newParkHistorico = $this->Historico->findByPlaca($placa);		// O histórico antes e depois deverá ser exatamente igual		$this->assertEquals($oldParkHistorico['Historico']['pago_ate'], $newParkHistorico['Historico']['pago_ate']);	} // End Method 'test_ComPeriodoVagaNormalTrocaVagaDeficienteMesmoPagoAte'	/**	 * Testa se o veículo lançado em uma vaga normal COM períodos vigentes for para uma vaga de deficiente, o mesmo	 * deverá manter o 'pago_ate' do ticket, continuando com sua situação igual a pago.	 * Depois o mesmo é verificado novamente me uma vaga normal, continuando como pago devido ao seu ticket vigente.	 */	public function testComPeriodoVagaNormalDeficienteNormal(){		// Cria valores default para o teste		$placa = 'XXX-1234';		$tempoLivre = 5;		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Atualiza o campo 'tempo_livre' do preço		$this->Preco->id = $this->dataGenerator->precoId;		$this->Preco->set('tempo_livre', $tempoLivre);		$this->Preco->save();		// Cria uma vaga de deficiente		$vagaDeficiente = $this->dataGenerator->createDeficientSpot();		// Cria uma vaga normal		$vagaNormal     = $this->dataGenerator->createNormalSpot();		// Salva dados necessários para efetuar uma compra de período em dinheiro		$this->dataGenerator->saveComissao(array('Comissao' => array('posto_id' => NULL)));		$this->dataGenerator->saveTarifa();		$this->dataGenerator->venderTicketEstacionamentoDinheiro('2.00', $placa, $vagaNormal['AreaPonto']['codigo']);		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga(deficiente)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaDeficiente['AreaPonto']['codigo'];		// Busca dados do histórico antes de enviar a requisição		$firstParkHistorico = $this->Historico->findByPlaca($placa);		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca dados do histórico depois do request		$secondParkHistorico = $this->Historico->findByPlaca($placa);		// Verifica novamente o veículo em uma vaga normal, ou seja não poderá alterar o campo pago_ate		$this->dataGenerator->verificaVeiculo($placa, $vagaNormal['AreaPonto']['codigo']);		// Busca os dados após a terceira verificação		$thirdParkHistorico = $this->Historico->findByPlaca($placa);		// O histórico antes e depois deverá ser exatamente igual		$this->assertEquals($firstParkHistorico['Historico']['pago_ate'], $secondParkHistorico['Historico']['pago_ate']);		$this->assertEquals($firstParkHistorico['Historico']['pago_ate'], $thirdParkHistorico['Historico']['pago_ate']);	} // End Method 'test_ComPeriodoVagaNormalDeficienteNormal'	/**	 * Testa verificação de uma placa em uma vaga de farmácia, sem ter preço vinculado a cobrança, 	 * verificando se o mesmo ganhará o tempo de remoção automática da área	 */	public function testVerificacaoFarmacia(){		// Cria valores default para o teste		$placa = 'XXX-1234';		$tempoLivre = 5;		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Atualiza o campo 'tempo_livre' do preço		$this->Preco->id = $this->dataGenerator->precoId;		$this->Preco->set('tempo_livre', $tempoLivre);		$this->Preco->save();		// Atualiza o campo de vínculo do preço da farmácia e preço do idoso na cobrança		$this->Cobranca->id = $this->dataGenerator->cobrancaId;		$this->Cobranca->set('preco_id_vaga_farmacia', null);		$this->Cobranca->set('preco_id_vaga_idoso', null);		$this->Cobranca->save();		// Primeira vaga		$vagaFarmacia = $this->dataGenerator->createPhamarcySpot();		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga(deficiente)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaFarmacia['AreaPonto']['codigo'];		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca dados do histórico antes de enviar a requisição		$parkHistorico = $this->Historico->findByPlaca($placa);		// Valida objeto do registro da park_historico		$this->assertNotNull($parkHistorico);		// Valida pago_ate		$this->assertNotNull($parkHistorico['Historico']['pago_ate']);		// Cria campos DateTime para comparação futura		$parkHistoricoInseridoEm    = new DateTime($parkHistorico['Historico']['inserido_em']);		$parkHistoricoPagoAte       = new DateTime($parkHistorico['Historico']['pago_ate']);		// Objeto do intervalo		$intervalInseridoEmPagoAte = $parkHistoricoInseridoEm->diff($parkHistoricoPagoAte);		// Valida se a diferença do tempo ganho no pago_ate é o valor do tempo de remoção automático da área		$this->assertEquals($tempoRemocaoAutomatica, $intervalInseridoEmPagoAte->i);		// Valida se a cobranca e o preco foram setados		$this->assertNotNull($parkHistorico['Historico']['cobranca_id']);		$this->assertNotNull($parkHistorico['Historico']['preco_id']);	} // End Method 'test_VerificacaoFarmacia'	/**	 * Testa verificação de uma placa de uma vaga de idoso, sem ter preço vinculado a cobrança, 	 * verificando se o mesmo ganhará o tempo de remoção automática da área	 */	public function testVerificacaoIdoso(){		// Cria valores default para o teste		$placa = 'XXX-1234';		$tempoLivre = 5;		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Atualiza o campo 'tempo_livre' do preço		$this->Preco->id = $this->dataGenerator->precoId;		$this->Preco->set('tempo_livre', $tempoLivre);		$this->Preco->save();		// Atualiza o campo de vínculo do preço da farmácia e preço do idoso na cobrança		$this->Cobranca->id = $this->dataGenerator->cobrancaId;		$this->Cobranca->set('preco_id_vaga_farmacia', null);		$this->Cobranca->set('preco_id_vaga_idoso', null);		$this->Cobranca->save();		// Primeira vaga		$vagaIdoso = $this->dataGenerator->createElderlySpot();		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga(deficiente)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaIdoso['AreaPonto']['codigo'];		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca dados do histórico antes de enviar a requisição		$parkHistorico = $this->Historico->findByPlaca($placa);				// Valida objeto do registro da park_historico		$this->assertNotNull($parkHistorico);		// Valida pago_ate		$this->assertNotNull($parkHistorico['Historico']['pago_ate']);		// Cria campos DateTime para comparação futura		$parkHistoricoInseridoEm    = new DateTime($parkHistorico['Historico']['inserido_em']);		$parkHistoricoPagoAte       = new DateTime($parkHistorico['Historico']['pago_ate']);		// Objeto do intervalo		$intervalInseridoEmPagoAte = $parkHistoricoInseridoEm->diff($parkHistoricoPagoAte);		// Valida se a diferença do tempo ganho no pago_ate é o valor do tempo de remoção automático da área		$this->assertEquals($tempoRemocaoAutomatica, $intervalInseridoEmPagoAte->i);		// Valida se a cobranca e o preco foram setados		$this->assertNotNull($parkHistorico['Historico']['cobranca_id']);		$this->assertNotNull($parkHistorico['Historico']['preco_id']);	} // End Method 'test_VerificacaoIdoso'	/**	 * Testa verificação de uma placa que está em uma vaga de farmácia e é verificado em uma vaga normal, 	 * verificando que o mesmo deverá atualizar o tempo do pago_ate com o horário atual	 */	public function testVerificacao_FarmaciaToNormal(){		// Cria valores default para o teste		$placa = 'XXX-1234';		$tempoLivre = 5;		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Atualiza o campo 'tempo_livre' do preço		$this->Preco->id = $this->dataGenerator->precoId;		$this->Preco->set('tempo_livre', $tempoLivre);		$this->Preco->save();		// Atualiza o campo de vínculo do preço da farmácia e preço do idoso na cobrança		$this->Cobranca->id = $this->dataGenerator->cobrancaId;		$this->Cobranca->set('preco_id_vaga_farmacia', null);		$this->Cobranca->set('preco_id_vaga_idoso', null);		$this->Cobranca->save();		// Primeira vaga		$vagaFarmacia = $this->dataGenerator->createPhamarcySpot();		// Segunda vaga		$vagaNormal = $this->dataGenerator->createNormalSpot();		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga(deficiente)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaFarmacia['AreaPonto']['codigo'];		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca dados do histórico antes de enviar a requisição		$parkHistorico = $this->Historico->findByPlaca($placa);		// Valida objeto do registro da park_historico		$this->assertNotNull($parkHistorico);		// Valida pago_ate		$this->assertNotNull($parkHistorico['Historico']['pago_ate']);		// Cria campos DateTime para comparação futura		$parkHistoricoInseridoEm    = new DateTime($parkHistorico['Historico']['inserido_em']);		$parkHistoricoPagoAte       = new DateTime($parkHistorico['Historico']['pago_ate']);		// Objeto do intervalo		$intervalInseridoEmPagoAte = $parkHistoricoInseridoEm->diff($parkHistoricoPagoAte);		// Valida se a diferença do tempo ganho no pago_ate é o valor do tempo de remoção automático da área		$this->assertEquals($tempoRemocaoAutomatica, $intervalInseridoEmPagoAte->i);		// Valida se a cobranca e o preco foram setados		$this->assertNotNull($parkHistorico['Historico']['cobranca_id']);		$this->assertNotNull($parkHistorico['Historico']['preco_id']);		// Efetua segunda verificação na mão pois não é possível efetuar dois requests		$this->dataGenerator->verificaVeiculo($placa, $vagaNormal['AreaPonto']['codigo']);		// Busca novo historico		$newParkHistorico = $this->Historico->findByPlaca($placa);		// Valida se encontrou registro		$this->assertNotNull($newParkHistorico);		// Valida o campo pago_ate se está com data atual		$this->assertEquals($newParkHistorico['Historico']['inserido_em'], $newParkHistorico['Historico']['pago_ate']);	} // End Method 'test_Verificacao_FarmaciaToNormal'	/**	 * Testa verificação de uma placa que está em uma vaga de idoso e é verificado em uma vaga normal, 	 * verificando que o mesmo deverá atualizar o tempo do pago_Ate com o horário atual	 */	public function testVerificacao_IdosoToNormal(){		// Cria valores default para o teste		$placa = 'XXX-1234';		$tempoLivre = 5;		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Atualiza o campo 'tempo_livre' do preço		$this->Preco->id = $this->dataGenerator->precoId;		$this->Preco->set('tempo_livre', $tempoLivre);		$this->Preco->save();		// Atualiza o campo de vínculo do preço da farmácia e preço do idoso na cobrança		$this->Cobranca->id = $this->dataGenerator->cobrancaId;		$this->Cobranca->set('preco_id_vaga_farmacia', null);		$this->Cobranca->set('preco_id_vaga_idoso', null);		$this->Cobranca->save();		// Primeira vaga		$vagaIdoso = $this->dataGenerator->createElderlySpot();		// Segunda vaga		$vagaNormal = $this->dataGenerator->createNormalSpot();		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga(deficiente)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaIdoso['AreaPonto']['codigo'];		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca dados do histórico antes de enviar a requisição		$parkHistorico = $this->Historico->findByPlaca($placa);		// Valida objeto do registro da park_historico		$this->assertNotNull($parkHistorico);		// Valida pago_ate		$this->assertNotNull($parkHistorico['Historico']['pago_ate']);		// Cria campos DateTime para comparação futura		$parkHistoricoInseridoEm    = new DateTime($parkHistorico['Historico']['inserido_em']);		$parkHistoricoPagoAte       = new DateTime($parkHistorico['Historico']['pago_ate']);		// Objeto do intervalo		$intervalInseridoEmPagoAte = $parkHistoricoInseridoEm->diff($parkHistoricoPagoAte);		// Valida se a diferença do tempo ganho no pago_ate é o valor do tempo de remoção automático da área		$this->assertEquals($tempoRemocaoAutomatica, $intervalInseridoEmPagoAte->i);		// Valida se a cobranca e o preco foram setados		$this->assertNotNull($parkHistorico['Historico']['cobranca_id']);		$this->assertNotNull($parkHistorico['Historico']['preco_id']);		// Efetua segunda verificação na mão pois não é possível efetuar dois requests		$this->dataGenerator->verificaVeiculo($placa, $vagaNormal['AreaPonto']['codigo']);		// Busca novo historico		$newParkHistorico = $this->Historico->findByPlaca($placa);		// Valida se encontrou registro		$this->assertNotNull($newParkHistorico);		// Valida o campo pago_ate se está com data atual		$this->assertEquals($newParkHistorico['Historico']['inserido_em'], $newParkHistorico['Historico']['pago_ate']);	} // End Method 'test_Verificacao_IdosoToNormal'	/**	 * Testa verificação de uma placa que está em uma vaga normal SEM ter período vigente e é verificado	 * em uma vaga de farmácia, verificando se o mesmo GANHARÁ tempo no campo 'pago_ate' correspondente ao tempo de remoção automática da área	 */	public function testVerificacao_NormalToFarmaciaSemPeriodo(){		// Cria valores default para o teste		$placa = 'XXX-1234';		$tempoLivre = 5;		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Atualiza o campo 'tempo_livre' do preço		$this->Preco->id = $this->dataGenerator->precoId;		$this->Preco->set('tempo_livre', $tempoLivre);		$this->Preco->save();		// Atualiza o campo de vínculo do preço da farmácia e preço do idoso na cobrança		$this->Cobranca->id = $this->dataGenerator->cobrancaId;		$this->Cobranca->set('preco_id_vaga_farmacia', null);		$this->Cobranca->set('preco_id_vaga_idoso', null);		$this->Cobranca->save();		// Primeira vaga		$vagaFarmacia = $this->dataGenerator->createPhamarcySpot();		// Segunda vaga		$vagaNormal = $this->dataGenerator->createNormalSpot();		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga(deficiente)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaNormal['AreaPonto']['codigo'];		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca dados do histórico antes de enviar a requisição		$parkHistorico = $this->Historico->findByPlaca($placa);		// Valida objeto do registro da park_historico		$this->assertNotNull($parkHistorico);		// Valida pago_ate deverá ganhar o tempo NOW() +  tempo de remoção automático		$this->assertNull($parkHistorico['Historico']['pago_ate']);		// Valida cobrança e preço afim de validar se os mesmos realmente estão sem vínculo		$this->assertEquals($this->dataGenerator->cobrancaId, $parkHistorico['Historico']['cobranca_id']);		$this->assertEquals($this->dataGenerator->precoId, $parkHistorico['Historico']['preco_id']);		// Efetua segunda verificação na mão pois não é possível efetuar dois requests		$this->dataGenerator->verificaVeiculo($placa, $vagaFarmacia['AreaPonto']['codigo']);		// Busca novo historico		$newParkHistorico = $this->Historico->findByPlaca($placa);		// Valida se encontrou registro		$this->assertNotNull($newParkHistorico);		// Data atual + tempo de remoção automática para comparação com o campo 'pago_ate'		$pagoAteComparator = $this->dataGenerator->getDateTime("+$tempoRemocaoAutomatica minutes");		// Valida o campo pago_ate se está com data atual + tempo de remoção automática		$this->assertEquals($pagoAteComparator, $newParkHistorico['Historico']['pago_ate']);	} // End Method 'test_Verificacao_NormalToFarmaciaSemPeriodo'	/**	 * Testa verificação de uma placa que está em uma vaga normal COM período vigente e é verificado	 * em uma vaga de farmácia, verificando se o mesmo MANTERÁ o tempo do campo 'pago_ate'	 */	public function testVerificacao_NormalToFarmaciaComPeriodo(){		// Cria valores default para o teste		$placa = 'XXX-1234';		$tempoLivre = 5;		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Atualiza o campo 'tempo_livre' do preço		$this->Preco->id = $this->dataGenerator->precoId;		$this->Preco->set('tempo_livre', $tempoLivre);		$this->Preco->save();		// Atualiza o campo de vínculo do preço da farmácia e preço do idoso na cobrança		$this->Cobranca->id = $this->dataGenerator->cobrancaId;		$this->Cobranca->set('preco_id_vaga_farmacia', null);		$this->Cobranca->set('preco_id_vaga_idoso', null);		$this->Cobranca->save();		// Primeira vaga		$vagaFarmacia = $this->dataGenerator->createPhamarcySpot();		// Segunda vaga		$vagaNormal = $this->dataGenerator->createNormalSpot();		// Compra período para a placa na vaga normal		$this->dataGenerator->saveComissao(array('Comissao' => array('posto_id' => null)));		$this->dataGenerator->saveTarifa();		$this->dataGenerator->venderTicketEstacionamentoDinheiro('2.00', $placa, $vagaNormal['AreaPonto']['codigo']);		// Busca registro na histórico para comparação após requisição		$oldParkHistorico = $this->Historico->findByPlaca($placa);		// Valida se encontrou o registro		$this->assertNotNull($oldParkHistorico);		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga(deficiente)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaFarmacia['AreaPonto']['codigo'];		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca dados do histórico antes de enviar a requisição		$newParkHistorico = $this->Historico->findByPlaca($placa);		// Valida objeto do registro da park_historico		$this->assertNotNull($newParkHistorico);		// Valida se o pago_ate está diferente de null		$this->assertNotNull($newParkHistorico['Historico']['pago_ate']);		// Valida se o pago_ate não foi modificado		$this->assertEquals($oldParkHistorico['Historico']['pago_ate'], $newParkHistorico['Historico']['pago_ate']);	} // End Method 'test_Verificacao_NormalToFarmaciaComPeriodo'	/**	 * Testa verificação de uma placa que está em uma vaga normal SEM ter período vigente e é verificado	 * em uma vaga de idoso, verificando se o mesmo GANHARÁ tempo no campo 'pago_ate' correspondente ao tempo de remoção automática da área	 */	public function testVerificacao_NormalToIdosoSemPeriodo(){		$placa = 'XXX-1234';		$tempoLivre = 5;		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Atualiza o campo 'tempo_livre' do preço		$this->Preco->id = $this->dataGenerator->precoId;		$this->Preco->set('tempo_livre', $tempoLivre);		$this->Preco->save();		// Atualiza o campo de vínculo do preço da farmácia e preço do idoso na cobrança		$this->Cobranca->id = $this->dataGenerator->cobrancaId;		$this->Cobranca->set('preco_id_vaga_farmacia', null);		$this->Cobranca->set('preco_id_vaga_idoso', null);		$this->Cobranca->save();		// Primeira vaga		$vagaIdoso = $this->dataGenerator->createElderlySpot();		// Segunda vaga		$vagaNormal = $this->dataGenerator->createNormalSpot();		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga(deficiente)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaNormal['AreaPonto']['codigo'];		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca dados do histórico antes de enviar a requisição		$parkHistorico = $this->Historico->findByPlaca($placa);		// Valida objeto do registro da park_historico		$this->assertNotNull($parkHistorico);		// Valida pago_ate deverá ganhar o tempo NOW() +  tempo de remoção automático		$this->assertNull($parkHistorico['Historico']['pago_ate']);		// Valida cobrança e preço afim de validar se os mesmos realmente estão sem vínculo		$this->assertEquals($this->dataGenerator->cobrancaId, $parkHistorico['Historico']['cobranca_id']);		$this->assertEquals($this->dataGenerator->precoId, $parkHistorico['Historico']['preco_id']);		// Efetua segunda verificação na mão pois não é possível efetuar dois requests		$this->dataGenerator->verificaVeiculo($placa, $vagaIdoso['AreaPonto']['codigo']);		// Busca novo historico		$newParkHistorico = $this->Historico->findByPlaca($placa);		// Valida se encontrou registro		$this->assertNotNull($newParkHistorico);		// Data atual + tempo de remoção automática para comparação com o campo 'pago_ate'		$pagoAteComparator = $this->dataGenerator->getDateTime("+$tempoRemocaoAutomatica minutes");		// Valida o campo pago_ate se está com data atual + tempo de remoção automática		$this->assertEquals($pagoAteComparator, $newParkHistorico['Historico']['pago_ate']);	} // End Method 'test_Verificacao_NormalToIdosoSemPeriodo'	/**	 * Testa verificação de uma placa que está em uma vaga normal COM período vigente e é verificado	 * em uma vaga de idoso, verificando se o mesmo MANTERÁ o tempo do campo  'pago_ate'	 */	public function testVerificacao_NormalToIdosoComPeriodo(){		// Cria valores default para o teste		$placa = 'XXX-1234';		$tempoLivre = 5;		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Atualiza o campo 'tempo_livre' do preço		$this->Preco->id = $this->dataGenerator->precoId;		$this->Preco->set('tempo_livre', $tempoLivre);		$this->Preco->save();		// Atualiza o campo de vínculo do preço da farmácia e preço do idoso na cobrança		$this->Cobranca->id = $this->dataGenerator->cobrancaId;		$this->Cobranca->set('preco_id_vaga_farmacia', null);		$this->Cobranca->set('preco_id_vaga_idoso', null);		$this->Cobranca->save();		// Primeira vaga		$vagaIdoso = $this->dataGenerator->createElderlySpot();		// Segunda vaga		$vagaNormal = $this->dataGenerator->createNormalSpot();		// Compra período para a placa na vaga normal		$this->dataGenerator->saveComissao(array('Comissao' => array('posto_id' => null)));		$this->dataGenerator->saveTarifa();		$this->dataGenerator->venderTicketEstacionamentoDinheiro('2.00', $placa, $vagaNormal['AreaPonto']['codigo']);		// Busca registro na histórico para comparação após requisição		$oldParkHistorico = $this->Historico->findByPlaca($placa);		// Valida se encontrou o registro		$this->assertNotNull($oldParkHistorico);		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga(deficiente)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaIdoso['AreaPonto']['codigo'];		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca dados do histórico antes de enviar a requisição		$newParkHistorico = $this->Historico->findByPlaca($placa);		// Valida objeto do registro da park_historico		$this->assertNotNull($newParkHistorico);		// Valida se o pago_ate está diferente de null		$this->assertNotNull($newParkHistorico['Historico']['pago_ate']);		// Valida se o pago_ate não foi modificado		$this->assertEquals($oldParkHistorico['Historico']['pago_ate'], $newParkHistorico['Historico']['pago_ate']);	} // End Method 'test_Verificacao_NormalToIdosoComPeriodo'	/**	 * Testa se após sair da vaga normal para farmacia e voltar para uma vaga normal, o mesmo deverá perder o tempo do	 * campo pago_ate	 */	public function testVerificacaoNormalToFarmaciaToNormal(){		// Cria valores default para o teste		$placa = 'XXX-1234';		$tempoLivre = 5;		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Atualiza o campo 'tempo_livre' do preço		$this->Preco->id = $this->dataGenerator->precoId;		$this->Preco->set('tempo_livre', $tempoLivre);		$this->Preco->save();		// Atualiza o campo de vínculo do preço da farmácia e preço do idoso na cobrança		$this->Cobranca->id = $this->dataGenerator->cobrancaId;		$this->Cobranca->set('preco_id_vaga_farmacia', null);		$this->Cobranca->set('preco_id_vaga_idoso', null);		$this->Cobranca->save();		// Primeira vaga		$vagaNormal = $this->dataGenerator->createNormalSpot();		// Segunda vaga		$vagaFarmacia = $this->dataGenerator->createPhamarcySpot();		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga (normal)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaNormal['AreaPonto']['codigo'];		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca dados do histórico antes de enviar a requisição		$parkHistorico = $this->Historico->findByPlaca($placa);		// Valida objeto do registro da park_historico		$this->assertNotNull($parkHistorico);		// Valida pago_ate		$this->assertNull($parkHistorico['Historico']['pago_ate']);		// Valida cobrança e preço afimd e validar se os mesmos realmente estão sem vínculo		$this->assertEquals($this->dataGenerator->cobrancaId, $parkHistorico['Historico']['cobranca_id']);		$this->assertEquals($this->dataGenerator->precoId, $parkHistorico['Historico']['preco_id']);		// Efetua segunda verificação na mão pois não é possível efetuar dois requests com vaga de farmacia		$this->dataGenerator->verificaVeiculo($placa, $vagaFarmacia['AreaPonto']['codigo']);		// Busca novo historico		$newParkHistorico = $this->Historico->findByPlaca($placa);		// Valida se encontrou registro		$this->assertNotNull($newParkHistorico);		// Cria campos DateTime para comparação futura		$parkHistoricoInseridoEm    = new DateTime($newParkHistorico['Historico']['inserido_em']);		$parkHistoricoPagoAte       = new DateTime($newParkHistorico['Historico']['pago_ate']);		// Objeto do intervalo		$intervalInseridoEmPagoAte = $parkHistoricoInseridoEm->diff($parkHistoricoPagoAte);		// Valida se a diferença do tempo ganho no pago_ate é o valor do tempo de remoção automático da área		$this->assertEquals($tempoRemocaoAutomatica, $intervalInseridoEmPagoAte->i);		// Efetua terceira verificação na mão pois não é possível efetuar dois requests com vaga novamente de carro		$this->dataGenerator->verificaVeiculo($placa, $vagaNormal['AreaPonto']['codigo']);		// Busca novo historico		$newNewParkHistorico = $this->Historico->findByPlaca($placa);		// Valida se encontrou registro		$this->assertNotNull($newNewParkHistorico);		// Valida o campo pago_ate se está com data atual		$this->assertEquals($newNewParkHistorico['Historico']['inserido_em'], $newNewParkHistorico['Historico']['pago_ate']);			}// End Method 'testVerificacaoNormalToFarmaciaToNormal'	/**	 * Testa verificação da vaga de farmácia para vaga isento onde deverá permanecer o pago_ate entre eles	 */	public function testVerificacao_FarmaciaToIsento(){		// Cria valores default para o teste		$placa = 'XXX-1234';		$tempoLivre = 5;		$tempoRemocaoAutomatica = 10;		// Atualiza o campo 'tempo de remoção automática' da área		$this->updateTempoRemocaoAutomatica($tempoRemocaoAutomatica);		// Atualiza o campo 'tempo_livre' do preço		$this->Preco->id = $this->dataGenerator->precoId;		$this->Preco->set('tempo_livre', $tempoLivre);		$this->Preco->save();		// Atualiza o campo de vínculo do preço da farmácia e preço do idoso na cobrança		$this->Cobranca->id = $this->dataGenerator->cobrancaId;		$this->Cobranca->set('preco_id_vaga_farmacia', null);		$this->Cobranca->set('preco_id_vaga_idoso', null);		$this->Cobranca->save();		// Primeira vaga		$vagaFarmacia = $this->dataGenerator->createPhamarcySpot();		// Segunda vaga		$vagaIsento = $this->dataGenerator->createFreeSpot();		// Popula os parâmetros de requisição, sobrescrevendo a placa e vaga (normal)		$this->data['placa'] = $placa;		$this->data['vaga'] = $vagaFarmacia['AreaPonto']['codigo'];		// Envia requisição para o veículo ser adicionado na vaga		$this->sendRequestData();		// Busca dados do histórico antes de enviar a requisição		$parkHistorico = $this->Historico->findByPlaca($placa);		// Valida objeto do registro da park_historico		$this->assertNotNull($parkHistorico);		// Valida pago_ate		$this->assertNotNull($parkHistorico['Historico']['pago_ate']);		// Cria campos DateTime para comparação futura		$parkHistoricoInseridoEm    = new DateTime($parkHistorico['Historico']['inserido_em']);		$parkHistoricoPagoAte       = new DateTime($parkHistorico['Historico']['pago_ate']);		// Objeto do intervalo		$intervalInseridoEmPagoAte = $parkHistoricoInseridoEm->diff($parkHistoricoPagoAte);		// Valida se a diferença do tempo ganho no pago_ate é o valor do tempo de remoção automático da área		$this->assertEquals($tempoRemocaoAutomatica, $intervalInseridoEmPagoAte->i);		// Valida se a cobranca e o preco foram setados				$this->assertEquals($this->dataGenerator->cobrancaId, $parkHistorico['Historico']['cobranca_id']);		$this->assertNotNull($parkHistorico['Historico']['preco_id']);		// Efetua segunda verificação na mão pois não é possível efetuar dois requests com vaga de farmacia		$this->dataGenerator->verificaVeiculo($placa, $vagaIsento['AreaPonto']['codigo']);		// Busca novo historico		$newParkHistorico = $this->Historico->findByPlaca($placa);		// Valida se encontrou registro		$this->assertNotNull($newParkHistorico);		// Valida se veículo continua pago		$this->assertEquals($parkHistorico['Historico']['pago_ate'], $newParkHistorico['Historico']['pago_ate']);	}// End Method 'test_Verificacao_FarmaciaToIsento'	/**	* Testa o lancamento de um veiculo que possui uma irregularidade com situacao igual a aguardando e cujo cliente possua debito automatico ativo	*/	public function testAddVehicleWithDAAndIrregularity() {		// Configura a area de acordo com as necessidades do teste		$this->Area->id = $this->dataGenerator->areaId;		$this->Area->saveField('bloquear_compra_irregularidade_pendente', 1);		$this->Area->saveField('numero_irregularidade_veiculo_advertido', 1);		$this->Area->saveField('debito_automatico_apos_tolerancia', 0);		$placa = $this->dataGenerator->randomPlaca();		$this->data['placa'] = $placa;		// Atualiza o preço para não ter tolerancia		$this->Preco->id = $this->dataGenerator->precoId;		$this->Preco->saveField('tempo_livre', 0);		// Utiliza no teste uma das vagas criadas no setup		$vaga = $this->AreaPonto->find('first');		$this->data['vaga'] = $vaga['AreaPonto']['codigo'];		// Cria cliente com DA		$cliente = $this->dataGenerator->getCliente();		$cliente['Cliente']['autorizar_debito'] = 1;		$this->dataGenerator->saveCliente($cliente);		// Concede limite pre ao cliente		$this->dataGenerator->concedeLimitePre($this->dataGenerator->clienteId, 10000);		// Vincula a placa ao cliente		$this->dataGenerator->savePlaca(array('Placa' => array('placa' => $placa)));				// Cria uma irregularidade não paga		$ticketIrregularidade = $this->dataGenerator->getTicket();		$ticketIrregularidade['Ticket']['placa']                 = $placa;		$ticketIrregularidade['Ticket']['situacao']              = 'AGUARDANDO';		$ticketIrregularidade['Ticket']['tipo']                  = 'IRREGULARIDADE';		$ticketIrregularidade['Ticket']['motivo_irregularidade'] = 'TICKET_INCOMPATIVEL';		$ticketIrregularidade['Ticket']['data_inicio'] 			 = $this->dataGenerator->getDateTime('-1 hour');        $ticketIrregularidade['Ticket']['data_fim'] 			 = $this->dataGenerator->getDateTime('-1 hour');		$this->dataGenerator->saveTicket($ticketIrregularidade);		try {    		// Tenta lancar o veiculo e valida se por conta do debito automatico e da irregularidade pendente a insercao do veiculo sera bloqueada.			$this->sendRequest($this->URL . $this->extension, 'POST', $this->data);    	} catch(Exception $e) {    		$this->fail($e->getMessage());    	}    	// Busca e valida o historico criado		$historico = $this->Historico->findByPlaca($placa);				$this->assertNotEmpty($historico);				// Valida o saldo do cliente para garantir que nao houve debito automatico		$limiteCliente = $this->Limite->findByEntidadeId($this->dataGenerator->clienteId);		$this->assertNotNull($limiteCliente);		$this->assertEquals(10000, ($limiteCliente['Limite']['pre_creditado'] + $limiteCliente['Limite']['pre_utilizado']));        	}// End method 'test_AddVehicle'	/**	 * Testa a ordenação da lista de veículos quando um veículo é lançado em uma vaga X, um outro veículo compra um período para esta vaga e	 * tenta trocá-lo novamente para a primeira placa	 */ 	public function testTrocaVeiculoComVerificacaoCompraPeriodo(){ 		// Cria comissao e tarifa geral 		$this->dataGenerator->saveComissao(array('Comissao' => array('posto_id' => null))); 		$this->dataGenerator->saveTarifa(); 		// Cria vaga 		$parkAreaPonto = $this->dataGenerator->getAreaPonto(); 		$this->dataGenerator->saveAreaPonto($parkAreaPonto); 		$vaga = $parkAreaPonto['AreaPonto']['codigo']; 		// Cria duas placa 		$placa1 = 'TST-1111'; 		$placa2 = 'TST-2222'; 		// Lança um veículo na vaga X 		$this->dataGenerator->verificaVeiculo($placa1, $vaga); 		// Busca historico da placa1 		$parkHistoricoPlaca1 = $this->Historico->findByPlaca($placa1); 		// Valida se encontrou 		$this->assertNotEmpty($parkHistoricoPlaca1); 		// Atualiza o campo 'ultima_verificacao' para 1 minuto antes 		$this->Historico->id = $parkHistoricoPlaca1['Historico']['id']; 		$this->Historico->saveField('ultima_verificacao', $this->dataGenerator->getDateTime('-1 hour')); 		// Compra um período na vaga X 		$this->dataGenerator->venderTicketEstacionamentoDinheiro($this->parkTarifa['ParkTarifa']['valor'], $placa2, $vaga); 		// Busca historico da placa2 		$parkHistoricoPlaca2 = $this->Historico->findByPlaca($placa2); 		// Valida se encontrou 		$this->assertNotEmpty($parkHistoricoPlaca2); 		// Atualiza o campo 'ultima_verificacao' para 1 minuto antes 		$this->Historico->id = $parkHistoricoPlaca2['Historico']['id']; 		$this->Historico->saveField('ultima_verificacao', $this->dataGenerator->getDateTime('-30 minutes')); 		// Popula dados da requisição 		$this->data['vaga'] = $vaga; 		$this->data['placa'] = $placa1; 		// Envia a requisição para efetuar a troca de veículo 		$this->sendRequest($this->URL . $this->extension, 'POST', $this->data); 		// Valida os resultados 		$this->assertTrue(isset($this->vars['data'])); 		$this->assertEquals($placa1, $this->vars['data']['park_historico']['placa']); 		$this->assertEquals($vaga, $this->vars['data']['park_historico']['vaga']); 		$this->assertEquals($parkHistoricoPlaca1['Historico']['id'], $this->vars['data']['park_historico']['id']); 		// Valida se o historico da placa 2 foi movida para vaga 0 		$parkHistoricoPlaca2New = $this->Historico->findByPlaca($placa2); 		$this->assertEquals(0, $parkHistoricoPlaca2New['Historico']['vaga']); 	}// End Method 'testTrocaVeiculoComVerificacaoCompraPeriodo'}// End Class